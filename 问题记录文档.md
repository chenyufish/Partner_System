* 开发框架一定要去看官方的最新文档，比如vant3到vant4就修改了Toast的轻提示方法，改为showTaost了

* 标签查询假如速度变慢的怎么办（用户大概超过20w），就要引入缓存技术了（缓存技术还可以用并发线程进行加速），实际上具体选择什么查询，可以去测量一下

* 关联查询很影响扩展性以及查询性能，最大级数应该不超过三重

* 用Gson里面的gson.fromJson(tagstr,new TypeToken<Set<String>>(){}.getType());既可以得到反序列化，因为java里面不支持直接拿去String<List>,所以我们就new一个TypeToken的一个泛型去get一个对象，相反可以使用tojson得到序列化

* 不使用List而使用Set优化时间复杂度

* 如果数据在1万以内的话，for循环效率高于foreach和stream；如果数据量在10万的时候，stream效率最高，其次是foreach,最后是for。

  另外需要注意的是如果数据达到100万的话，[parallelStream](https://so.csdn.net/so/search?q=parallelStream&spm=1001.2101.3001.7020)异步并行处理效率最高，高于foreach和for。并行流（ParallelStream）怎么会比顺序流（Stream）还要慢。。

  实际上并行流（ParallelStream）的背后其实是 Java7 开始支持的 Fork/Join，即把一个大任务拆分成 N 个小任务，然后最终合并各个子任务的结果，所以对于子任务线程的拆分、创建、结果合并等操作都需要不少的开销，特别是线程的创建。

  所以不耗时的简单排序操作事实上是不适用于并行流（ParallelStream）的，它所带来的线程创建的损耗可能还会比顺序流（Stream）还要更慢。
  既然使用 [Fork/Join](https://mp.weixin.qq.com/s/YQa2_daDZbJsTxrqv45-QQ) 是会有损耗的，那对于单条数据的处理的时间最好是理论上要超过用并行流（ParallelStream）本身的损耗，这种情况下就比较合适。

* 在java里面任何集合都要判断空

* 对于加了序列化的注册程序来说，直接在数据库里面增加账号是不能访问的，要调用注册接口实现账号增加

* 单机登录改为分布式登录，允许多台服务器登录对用户进行更改

* 关于用户头像，我们可以设计一个防盗链referrer，但是这个仅仅适用于前端，如果从后台请求的话可以伪造请求方依旧可以拿到头像。可以在index里面加<meta name="referrer"content="none"/>进行伪装，如果别人禁用了no-referrer，那么就拿不到

* SpringMvc一般会自动映射GET方法传参的值

* 跨域是浏览器层面的问题，当我们的协议号或者端口号，或者域名不一样的时候，留啦起就会认为不安全而拒绝我们的访问

* 关于前端和后端请求参数失败了有一种可能是请求的参数格式有问题。解决方法要么修改前端的list改为数组，要么使用axios的序列化![image-20240325174313866](C:\Users\fishman\AppData\Roaming\Typora\typora-user-images\image-20240325174313866.png)

  序列化里面的indecis是请求是形式

  ![image-20240325175347085](C:\Users\fishman\AppData\Roaming\Typora\typora-user-images\image-20240325175347085.png)

  

* http一般以4（400,401）开头的错误码一般都是用户方面的问题

* 对于同一个前端来说，哪怕是不同端口，但如果是同一个域名下，种出来的cookie是一样的会相互覆盖影响

* 如果执行Mavan的生命周期里面的package出现Test报错，那么就是test里面有错误的地方没有跳过，可以使用命令

  ```
  mvn package -DskipTests=true
  ```

  或者在pom里面改跳过，或者关掉小闪电
  
* 在启动前端dev的时候出现了error when starting dev server:                                 Error: listen EACCES: permission denied 127.0.0.1:5173 

  应该是端口占用了，可以用netstat查看端口，或者直接换端口启动npm run dev -- --port 81

* JWT比较适合有效期短一点，一次性的验证