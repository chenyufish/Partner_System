* 开发框架一定要去看官方的最新文档，比如vant3到vant4就修改了Toast的轻提示方法，改为showTaost了

* 标签查询假如速度变慢的怎么办（用户大概超过20w），就要引入缓存技术了（缓存技术还可以用并发线程进行加速），实际上具体选择什么查询，可以去测量一下

* 关联查询很影响扩展性以及查询性能，最大级数应该不超过三重

* 用Gson里面的gson.fromJson(tagstr,new TypeToken<Set<String>>(){}.getType());既可以得到反序列化，因为java里面不支持直接拿去String<List>,所以我们就new一个TypeToken的一个泛型去get一个对象，相反可以使用tojson得到序列化

* 不使用List而使用Set优化时间复杂度

* 如果数据在1万以内的话，for循环效率高于foreach和stream；如果数据量在10万的时候，stream效率最高，其次是foreach,最后是for。

  另外需要注意的是如果数据达到100万的话，[parallelStream](https://so.csdn.net/so/search?q=parallelStream&spm=1001.2101.3001.7020)异步并行处理效率最高，高于foreach和for。并行流（ParallelStream）怎么会比顺序流（Stream）还要慢。。

  实际上并行流（ParallelStream）的背后其实是 Java7 开始支持的 Fork/Join，即把一个大任务拆分成 N 个小任务，然后最终合并各个子任务的结果，所以对于子任务线程的拆分、创建、结果合并等操作都需要不少的开销，特别是线程的创建。

  所以不耗时的简单排序操作事实上是不适用于并行流（ParallelStream）的，它所带来的线程创建的损耗可能还会比顺序流（Stream）还要更慢。
  既然使用 [Fork/Join](https://mp.weixin.qq.com/s/YQa2_daDZbJsTxrqv45-QQ) 是会有损耗的，那对于单条数据的处理的时间最好是理论上要超过用并行流（ParallelStream）本身的损耗，这种情况下就比较合适。

* 在java里面任何集合都要判断空

* 对于加了序列化的注册程序来说，直接在数据库里面增加账号是不能访问的，要调用注册接口实现账号增加

* 单机登录改为分布式登录，允许多台服务器登录对用户进行更改

* 关于用户头像，我们可以设计一个防盗链referrer，但是这个仅仅适用于前端，如果从后台请求的话可以伪造请求方依旧可以拿到头像。可以在index里面加<meta name="referrer"content="none"/>进行伪装，如果别人禁用了no-referrer，那么就拿不到

* SpringMvc一般会自动映射GET方法传参的值

* 跨域是浏览器层面的问题，当我们的协议号或者端口号，或者域名不一样的时候，留啦起就会认为不安全而拒绝我们的访问

* 关于前端和后端请求参数失败了有一种可能是请求的参数格式有问题。解决方法要么修改前端的list改为数组，要么使用axios的序列化![image-20240325174313866](C:\Users\fishman\AppData\Roaming\Typora\typora-user-images\image-20240325174313866.png)

  序列化里面的indecis是请求是形式

  ![image-20240325175347085](C:\Users\fishman\AppData\Roaming\Typora\typora-user-images\image-20240325175347085.png)

  

* http一般以4（400,401）开头的错误码一般都是用户方面的问题

* 对于同一个前端来说，哪怕是不同端口，但如果是同一个域名下，种出来的cookie是一样的会相互覆盖影响

* 如果执行Mavan的生命周期里面的package出现Test报错，那么就是test里面有错误的地方没有跳过，可以使用命令

  ```
  mvn package -DskipTests=true
  ```

  或者在pom里面改跳过，或者关掉小闪电
  
* 在启动前端dev的时候出现了error when starting dev server:                                 Error: listen EACCES: permission denied 127.0.0.1:5173 

  应该是端口占用了，可以用netstat查看端口，或者直接换端口启动npm run dev -- --port 81

* JWT比较适合有效期短一点，一次性的验证，另外JWT配置起来也有点麻烦，使用session加上redis集成了spring，简单操作易维护

* spring security更是重量级的产物，里面的权限更是细分

* 做登录页面的时候会因为前端的cookie没有传输给后端导致获取当前用户信息失败，响应信息会显示未登录，根据浏览器cookie发现已经种好了，但是Axios发送请求的时候好像没带上cookie

* 在vue route3版本以上自动把hash模式改为了history模式，网址默认不加#，可以使用：history 对应 createWebHistory
  hash 对应 createWebHashHistory改成hash
  
* cookie的问题一般只会和domain和path有关，假如前后端的端口号或则协议号不一样，会因为浏览器的同源保护机制阻止cookie的请求引入，要解决这个问题需要在前端axios里面开启axios.defaults.withCredentials = true;同时在后端的webmvcconfig里面开启Access-Control-Allow-Credentials: true以及增加跨域端口号

* 由于前端的axios对respon又进行了一层的封装，所以在搜索结果页面，在序列化打平的时候要把respon.data.data改为respond.data

  ![image-20240326203403768](C:\Users\fishman\AppData\Roaming\Typora\typora-user-images\image-20240326203403768.png)

* axios 默认是异步请求，若想等请求返回数据后再往下执行代码，请在需要调用axios的方法前加 [async](https://so.csdn.net/so/search?q=async&spm=1001.2101.3001.7020) 关键字，且在调用axios请求时加上 await 关键字发送同步请求。

* JavaScript里面有一个动态获取用户方法，使用中括号[editUser.value.editKey]: editUser.value.currentValue // 动态取值

* 面对小量的用户，前端并不是很需要使用缓存，直接使用Axios去get currentuser